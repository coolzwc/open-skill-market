---
import type { CompactSkill } from "@/lib/market-data";
import type { Lang } from "@/lib/i18n";
import { MESSAGES } from "@/lib/i18n";

interface Props {
  lang: Lang;
  initialSkills: CompactSkill[];
  initialRepositories: Record<string, { stars?: number; forks?: number }>;
  cdnBaseUrl: string;
  totalSkills: number;
  categories: string[];
}

const { lang, initialSkills, initialRepositories, cdnBaseUrl, totalSkills, categories } = Astro.props;
const t = MESSAGES[lang];
---

<section class="animate-in delay-2" style="flex:1;display:flex;flex-direction:column;overflow:hidden;">
  <input id="skill-category-hidden" type="hidden" value="" />
  <div class="scroll-region" id="scroll-region">
    <div id="skill-grid" class="card-grid"></div>
    <div id="skill-empty" class="empty-state" style="display:none;">{t.noResults}</div>
    <div id="skill-loading" class="loading-spinner">{t.loading}</div>
  </div>
</section>

<script type="application/json" id="initial-skills" set:html={JSON.stringify(initialSkills)}></script>
<script type="application/json" id="initial-repositories" set:html={JSON.stringify(initialRepositories)}></script>

<script
  type="module"
  define:vars={{
    lang,
    cdnBaseUrl,
    totalSkills,
    noResultsText: t.noResults,
    loadingText: t.loading,
    starsText: t.stars
  }}
>
  const searchInput = document.querySelector("#skill-search");
  const categoryHidden = document.querySelector("#skill-category-hidden");
  const grid = document.querySelector("#skill-grid");
  const empty = document.querySelector("#skill-empty");
  const loading = document.querySelector("#skill-loading");
  const scrollRegion = document.querySelector("#scroll-region");

  const initialSkills = JSON.parse(document.querySelector("#initial-skills").textContent || "[]");
  const repositories = JSON.parse(
    document.querySelector("#initial-repositories").textContent || "{}"
  );

  const PAGE_SIZE = 60;

  // ---- Track known skill IDs for deduplication ----
  const knownIds = new Set();

  // ---- Pre-built search index for fast filtering ----
  const searchIndex = new Map();

  function indexSkill(skill) {
    if (searchIndex.has(skill.id)) return;
    const haystack = [
      skill.name, skill.description, skill.author, skill.repo,
      ...(skill.tags || [])
    ].join(" ").toLowerCase();
    searchIndex.set(skill.id, haystack);
  }

  function getScore(skill) {
    const repo = repositories[skill.repo] || {};
    return Number(repo.stars || 0);
  }

  // ---- State ----
  const state = {
    skills: [...initialSkills],
    filtered: [],
    rendered: 0,
    busy: false,
    fullyLoaded: false
  };

  // Index + track initial skills
  for (const s of initialSkills) {
    knownIds.add(s.id);
    indexSkill(s);
  }

  // ---- Escape HTML (cached via template) ----
  const _escEl = document.createElement("span");
  function esc(str) {
    if (!str) return "";
    _escEl.textContent = str;
    return _escEl.innerHTML;
  }

  // ---- Build card HTML ----
  function cardHtml(skill) {
    const stars = getScore(skill);
    const href = `/${lang}/skill/${encodeURIComponent(skill.id)}`;
    const cat = esc(skill.categories?.[0] || "Other");
    return `<a class="card" href="${href}">
      <span class="card-category" data-cat="${cat}">${cat}</span>
      <h3>${esc(skill.name)}</h3>
      <p class="card-desc">${esc(skill.description || "")}</p>
      <div class="card-footer">
        <span class="card-author">@${esc(skill.author || "unknown")}</span>
        <span class="card-stars">
          <svg viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01z"/></svg>
          ${stars.toLocaleString()}
        </span>
      </div>
    </a>`;
  }

  // ---- Render a batch of cards using DocumentFragment ----
  function renderBatch(startIdx, count) {
    const end = Math.min(startIdx + count, state.filtered.length);
    if (startIdx >= end) return;
    const frag = document.createDocumentFragment();
    const tmp = document.createElement("div");
    for (let i = startIdx; i < end; i++) {
      tmp.innerHTML = cardHtml(state.filtered[i]);
      frag.appendChild(tmp.firstElementChild);
    }
    grid.appendChild(frag);
    state.rendered = end;
  }

  // ---- Filter + render (only first page) ----
  function applyFilter() {
    const q = String(searchInput?.value || "").trim().toLowerCase();
    const category = String(categoryHidden?.value || "");

    state.filtered = state.skills.filter((skill) => {
      if (category && !(skill.categories || []).includes(category)) return false;
      if (!q) return true;
      return (searchIndex.get(skill.id) || "").includes(q);
    });

    state.filtered.sort((a, b) => getScore(b) - getScore(a) || String(a.name).localeCompare(String(b.name)));

    // Clear and render first page
    grid.innerHTML = "";
    state.rendered = 0;
    renderBatch(0, PAGE_SIZE);
    empty.style.display = state.filtered.length === 0 ? "block" : "none";
  }

  // ---- Infinite scroll: load more on scroll ----
  let scrollTicking = false;
  scrollRegion?.addEventListener("scroll", () => {
    if (scrollTicking) return;
    scrollTicking = true;
    requestAnimationFrame(() => {
      scrollTicking = false;
      if (state.rendered >= state.filtered.length) return;
      const el = scrollRegion;
      if (el.scrollTop + el.clientHeight >= el.scrollHeight - 400) {
        renderBatch(state.rendered, PAGE_SIZE);
      }
    });
  }, { passive: true });

  // ---- Merge a fetched payload (skills + repos) into state ----
  function mergePayload(payload) {
    Object.assign(repositories, payload.repositories || {});
    const newSkills = (payload.skills || []).filter((s) => !knownIds.has(s.id));
    for (const s of newSkills) {
      knownIds.add(s.id);
      indexSkill(s);
    }
    state.skills.push(...newSkills);
    return newSkills.length;
  }

  // ---- Hybrid loading: fetch full data from R2 CDN ----
  async function loadFromCDN() {
    if (state.busy) return;
    state.busy = true;
    loading.style.display = "flex";
    loading.textContent = `${loadingText}...`;

    try {
      // Step 1: Fetch the main skills.json from R2 CDN
      const mainResp = await fetch(`${cdnBaseUrl}/skills.json`);
      if (!mainResp.ok) throw new Error(`Failed to fetch skills.json from CDN (${mainResp.status})`);
      const mainData = await mainResp.json();
      const addedMain = mergePayload(mainData);
      if (addedMain > 0) applyFilter();

      // Step 2: Fetch chunk files listed in the CDN response
      const chunkFiles = mainData.meta?.chunks || [];
      for (let i = 0; i < chunkFiles.length; i++) {
        loading.textContent = `${loadingText} (${i + 1}/${chunkFiles.length + 1})`;
        try {
          const chunkResp = await fetch(`${cdnBaseUrl}/${chunkFiles[i]}`);
          if (!chunkResp.ok) throw new Error(`Failed chunk ${chunkFiles[i]}`);
          const chunkData = await chunkResp.json();
          const addedChunk = mergePayload(chunkData);
          if (addedChunk > 0) applyFilter();
        } catch (chunkErr) {
          console.error(chunkErr);
        }
      }

      state.fullyLoaded = true;
      loading.style.display = "none";
    } catch (error) {
      console.error("CDN load failed:", error);
      loading.style.display = "none";
    } finally {
      state.busy = false;
    }
  }

  // ---- Schedule CDN fetch after initial render ----
  function scheduleCDNLoad() {
    const run = () => loadFromCDN();
    if ("requestIdleCallback" in window) {
      window.requestIdleCallback(run, { timeout: 1500 });
    } else {
      setTimeout(run, 200);
    }
  }

  // ---- Session storage persistence ----
  const STORAGE_KEY = "skill-market-filter";

  function saveFilterState() {
    const q = String(searchInput?.value || "").trim();
    const cat = String(categoryHidden?.value || "");
    try { sessionStorage.setItem(STORAGE_KEY, JSON.stringify({ cat, q })); } catch {}
  }

  function restoreFilterState() {
    try {
      const raw = sessionStorage.getItem(STORAGE_KEY);
      if (!raw) return;
      const { cat, q } = JSON.parse(raw);
      if (searchInput && q) searchInput.value = q;
      if (categoryHidden && cat) {
        categoryHidden.value = cat;
        document.querySelectorAll(".sidebar-item[data-category]").forEach((item) => {
          item.classList.toggle("active", item.dataset.category === cat);
        });
        document.querySelectorAll(".mobile-cat-chip[data-category]").forEach((chip) => {
          chip.classList.toggle("active", chip.dataset.category === cat);
        });
      }
    } catch {}
  }

  // ---- Input listeners (debounced search) ----
  let debounceTimer = 0;
  searchInput?.addEventListener("input", () => {
    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(() => {
      saveFilterState();
      applyFilter();
    }, 200);
  });

  categoryHidden?.addEventListener("change", () => {
    saveFilterState();
    applyFilter();
  });

  // ---- Init ----
  restoreFilterState();
  applyFilter();
  scheduleCDNLoad();
</script>
